<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TBM Bus Tracker</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<style>
  body { font-family: 'Roboto', sans-serif; margin:0; background: linear-gradient(to right, #4facfe, #00f2fe); color:white; min-height:100vh; }
  h1 { text-align:center; margin:20px 0; font-size:2rem; }
  .container { padding:10px; }
  .card { background: rgba(255,255,255,0.1); padding:15px; border-radius:12px; margin-bottom:10px; cursor:pointer; transition: transform 0.3s, background 0.3s; }
  .card:hover { transform: scale(1.05); background: rgba(255,255,255,0.2); }
  .back-btn { margin-bottom:15px; display:inline-block; cursor:pointer; text-decoration: underline; }
  .arrival-time { background: rgba(0,0,0,0.2); padding:10px; border-radius:10px; margin-top:5px; }
</style>
</head>
<body>

<h1>TBM Bus Tracker</h1>
<div class="container" id="app"></div>

<script>
const ACCOUNT_KEY = "opendata-bordeaux-metropole-flux-gtfs-rt";
const BASE_SIRI = `https://bdx.mecatran.com/utw/ws/siri/2.0/bordeaux`;

const app = document.getElementById('app');

// Liste de quelques lignes TBM pour exemple (SIRI Lite n'a pas un endpoint "all lines")
const LINES = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]; // tu peux compléter

// Affiche toutes les lignes TBM
function showLines() {
  app.innerHTML = '';
  LINES.forEach(lineCode => {
    const div = document.createElement('div');
    div.className = 'card';
    div.textContent = `Ligne ${lineCode}`;
    div.onclick = () => showLineStops(lineCode);
    app.appendChild(div);
  });
}

// Affiche les arrêts d'une ligne via SIRI Lite
async function showLineStops(lineCode) {
  app.innerHTML = `<div class="back-btn" onclick="showLines()">← Retour</div>
                   <h2>Arrêts de la ligne ${lineCode}</h2>`;
  try {
    const res = await fetch(`${BASE_SIRI}?LineRef=${lineCode}`);
    const data = await res.json();
    const stops = data.Siri.ServiceDelivery.StopMonitoringDelivery[0].MonitoredStopVisit || [];
    stops.forEach(stop => {
      const stopId = stop.MonitoredVehicleJourney.MonitoredCall.StopPointRef;
      const stopName = stop.MonitoredVehicleJourney.MonitoredCall.StopPointName;
      const div = document.createElement('div');
      div.className = 'card';
      div.textContent = stopName;
      div.onclick = () => showStopDepartures(stopId, stopName);
      app.appendChild(div);
    });
  } catch(err) {
    app.innerHTML += `<p>Erreur lors du chargement des arrêts : ${err}</p>`;
  }
}

// Affiche les prochains départs pour un arrêt
async function showStopDepartures(stopId, stopName) {
  app.innerHTML = `<div class="back-btn" onclick="showLines()">← Retour</div>
                   <h2>Arrêt : ${stopName}</h2>`;
  try {
    const res = await fetch(`${BASE_SIRI}?stopPointRef=${stopId}`);
    const data = await res.json();
    const departures = data.Siri.ServiceDelivery.StopMonitoringDelivery[0].MonitoredStopVisit || [];
    if (departures.length === 0) {
      app.innerHTML += `<p>Aucun départ prévu pour l'instant.</p>`;
      return;
    }
    departures.forEach(dep => {
      const div = document.createElement('div');
      div.className = 'card arrival-time';
      const journey = dep.MonitoredVehicleJourney;
      const dir = journey.DirectionName || "Direction inconnue";
      const aimedTime = new Date(journey.MonitoredCall.AimedDepartureTime);
      const now = new Date();
      const minutesLeft = Math.max(Math.round((aimedTime - now)/60000), 0);
      div.textContent = `${dir} → dans ${minutesLeft} min`;
      app.appendChild(div);
    });
  } catch(err) {
    app.innerHTML += `<p>Erreur lors du chargement des départs : ${err}</p>`;
  }
}

// Démarrage
showLines();
</script>

</body>
</html>
