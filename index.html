<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Radio H24 â€” lecteur synchronisÃ©</title>
<style>
  :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa6b2;--accent:#7dd3fc}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#e6eef6;background:linear-gradient(180deg,var(--bg),#071027)}
  .wrap{max-width:980px;margin:28px auto;padding:18px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
  header{display:flex;align-items:center;gap:16px}
  h1{margin:0;font-size:20px}
  .art{width:120px;height:120px;border-radius:8px;background:linear-gradient(90deg,#061226,#0b233a);display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:12px}
  .meta{flex:1}
  .title{font-weight:700;font-size:18px;margin:0}
  .subtitle{color:var(--muted);margin-top:6px}
  .controls{display:flex;gap:12px;align-items:center;margin-top:12px}
  button.big{padding:10px 18px;border-radius:10px;background:linear-gradient(90deg,var(--accent),#0284c7);border:none;color:#012;cursor:pointer;font-weight:700}
  .vol{display:flex;align-items:center;gap:8px}
  input[type=range]{width:160px}
  .info{margin-top:14px;color:var(--muted);font-size:14px}
  .notice{margin-top:10px;color:#ffd0d0;background:rgba(255,200,200,0.03);padding:8px;border-radius:8px}
  footer{margin-top:18px;color:var(--muted);font-size:12px}
  code{background:#031124;padding:4px;border-radius:4px;color:#7dd3fc}
  .small{font-size:13px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="art" id="art">â€”</div>
    <div class="meta">
      <h1>Radio H24 â€” Lecture synchronisÃ©e</h1>
      <div class="subtitle small" id="trackInfo">Chargement des pistes...</div>
      <div class="controls">
        <button id="listenBtn" class="big">Ã‰couter</button>
        <div class="vol small">
          ðŸ”Š
          <input id="vol" type="range" min="0" max="1" step="0.01" value="0.9" />
        </div>
        <div class="small" style="margin-left:auto" id="syncState">...</div>
      </div>
      <div class="info" id="timeInfo">â€”</div>
      <div class="notice small" id="notice" style="display:none"></div>
    </div>
  </header>

  <section style="margin-top:14px" id="debugArea" class="small"></section>

  <footer>
    <div>Remarques techniques : le dossier attendu est <code>/musique/</code> (mÃªmes origine). Si le serveur n'autorise pas le listing, crÃ©e un fichier <code>/musique/list.json</code> (ex : <code>["track1.mp3","track2.mp3"]</code>).</div>
  </footer>
</div>

<script>
/*
  radio.html â€” Single-file synchronized radio front-end
  - DÃ©pendances externes : aucune
  - Requirements serveur : servir index.html et dossier /musique/ depuis la mÃªme origine.
  - Metadata search : iTunes Search API (CORS-friendly). Si rien trouvÃ©, on affiche le nom de fichier.
*/

/* ---------- CONFIG ---------- */
// Chemin vers le dossier musique (doit Ãªtre servi depuis la mÃªme origine)
const MUSIC_DIR = '/musique/'; // ajuste si nÃ©cessaire

// Timeout pour rÃ©cupÃ©rer metadata des fichiers (ms)
const METADATA_TIMEOUT = 12000;

// iTunes search fallback (no API key required)
const ITUNES_SEARCH_URL = (q)=>`https://itunes.apple.com/search?media=music&term=${encodeURIComponent(q)}&limit=1`;

/* ---------- UTIL ---------- */
function log(...a){ /*console.log*/ }
function fmtTime(s){
  if (isFinite(s)===false || s<0) return '--:--';
  s = Math.max(0, Math.floor(s));
  const mm = Math.floor(s/60).toString().padStart(2,'0');
  const ss = (s%60).toString().padStart(2,'0');
  return `${mm}:${ss}`;
}
function extless(name){ return name.replace(/\.[^.]+$/,''); }

/* seeded RNG (xorshift32) */
function seededRng(seed){
  let x = (seed|0) + 0x9e3779b9|0;
  return function(){
    x ^= x << 13;
    x ^= x >>> 17;
    x ^= x << 5;
    return (x >>> 0) / 4294967295;
  }
}

/* deterministic shuffle */
function shuffleArray(arr, seed){
  const rnd = seededRng(seed);
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(rnd()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

/* try to fetch server time via HEAD to same origin root */
async function fetchServerTime(){
  try{
    const resp = await fetch(window.location.pathname, {method:'HEAD', cache:'no-store'});
    const date = resp.headers.get('Date');
    if (date) return new Date(date);
  }catch(e){
    // silent
  }
  // fallback to client time (less reliable)
  return new Date();
}

/* ---------- UI refs ---------- */
const artEl = document.getElementById('art');
const trackInfoEl = document.getElementById('trackInfo');
const timeInfoEl = document.getElementById('timeInfo');
const listenBtn = document.getElementById('listenBtn');
const volRange = document.getElementById('vol');
const syncStateEl = document.getElementById('syncState');
const noticeEl = document.getElementById('notice');
const debugArea = document.getElementById('debugArea');

/* ---------- Main state ---------- */
let trackFiles = []; // array of filenames relative to MUSIC_DIR
let tracks = []; // {url, filename, title, artist, artwork, duration}
let totalDuration = 0;
let seededOrder = []; // array of indices in play order
let audioEls = []; // <audio> elements (one per track)
let audioCtx, gainNode;
let started = false;
let serverTimeOffset = 0; // ms: serverNow - clientNow

/* ---------- File listing: tries several strategies ---------- */
async function listMusicFiles(){
  // 1) try /musique/list.json
  try{
    const resp = await fetch(MUSIC_DIR + 'list.json', {cache:'no-cache'});
    if (resp.ok){
      const arr = await resp.json();
      if (Array.isArray(arr) && arr.length) { return arr; }
    }
  }catch(e){ /* ignore */ }

  // 2) try to fetch the directory root and parse links (works if server returns directory listing HTML)
  try{
    const resp = await fetch(MUSIC_DIR, {cache:'no-cache'});
    if (resp.ok){
      const txt = await resp.text();
      // attempt to find hrefs ending with .mp3
      const matches = [...txt.matchAll(/href="([^"]+\.mp3)"/ig)].map(m=>m[1]);
      if (matches.length) return matches;
      // some server list without quotes
      const matches2 = [...txt.matchAll(/([^\s'"]+\.mp3)/ig)].map(m=>m[1]);
      if (matches2.length) return matches2;
    }
  }catch(e){ /* ignore */ }

  // 3) fallback: try a few common names (user should edit)
  return [
    // Ã‰dite ici si tu veux lister manuellement :
    // "exemple.mp3"
  ];
}

/* ---------- Metadata lookup (iTunes) ---------- */
async function fetchMetaForName(nameNoExt){
  // sanitize name (replace _ and - with spaces)
  const q = nameNoExt.replace(/[_\-]+/g,' ').replace(/\s+/g,' ').trim();
  if (!q) return null;
  try{
    const resp = await fetch(ITUNES_SEARCH_URL(q));
    if (!resp.ok) return null;
    const j = await resp.json();
    if (j.resultCount>0){
      const r = j.results[0];
      return {
        artist: r.artistName,
        title: r.trackName || nameNoExt,
        artwork: r.artworkUrl100 ? r.artworkUrl100.replace('100x100bb','600x600bb') : null
      }
    }
  }catch(e){ /* ignore */ }
  return null;
}

/* ---------- Load all tracks and their durations ---------- */
async function prepareTracks(){
  trackFiles = await listMusicFiles();
  debugArea.innerText = `Fichiers trouvÃ©s: ${trackFiles.length}\n(essaye /musique/list.json si tu n'as rien)`;
  if (!trackFiles.length){
    noticeEl.style.display='block';
    noticeEl.innerText = "Aucun fichier dÃ©tectÃ© dans /musique/. CrÃ©e /musique/list.json ou dÃ©pose des .mp3 dans /musique/.";
    trackInfoEl.innerText = "Aucune piste.";
    return;
  }

  // Build tracks array
  tracks = trackFiles.map(fn=>({
    filename: fn,
    url: MUSIC_DIR + fn,
    title: extless(fn),
    artist: '',
    artwork: null,
    duration: 0
  }));

  // Create audio elements and load metadata
  audioEls = tracks.map(t=>{
    const a = document.createElement('audio');
    a.src = t.url;
    a.preload = 'metadata';
    a.crossOrigin = 'anonymous';
    return a;
  });

  // Wait for metadata loaded or timeout
  const metaPromises = tracks.map((t,i)=>new Promise(resolve=>{
    const a = audioEls[i];
    let done=false;
    const onloaded = ()=>{
      if(done) return;
      done=true;
      t.duration = isFinite(a.duration) ? a.duration : 0;
      resolve();
    };
    a.addEventListener('loadedmetadata', onloaded, {once:true});
    a.addEventListener('error', ()=>{ if(!done){done=true;t.duration=0;resolve()} }, {once:true});
    // safety timeout
    setTimeout(()=>{ if(!done){done=true;t.duration = t.duration || 0; resolve()} }, METADATA_TIMEOUT);
  }));

  await Promise.all(metaPromises);

  // Fetch metadata (artist/artwork) in parallel (but limited)
  const metaFetches = tracks.map(async (t)=>{
    const n = extless(t.filename).replace(/\d{4}/g,'').trim(); // try remove stray year numbers
    const meta = await fetchMetaForName(n);
    if (meta){
      t.artist = meta.artist || '';
      t.title = meta.title || t.title;
      t.artwork = meta.artwork || null;
    } else {
      // fallback: try splitting "Artist - Title"
      const parts = n.split(' - ');
      if (parts.length>=2){
        t.artist = parts[0].trim();
        t.title = parts.slice(1).join(' - ').trim();
      } else {
        t.artist = '';
        t.title = n;
      }
    }
  });

  await Promise.all(metaFetches);

  totalDuration = tracks.reduce((s,t)=>s + (t.duration||0), 0);
  if (!totalDuration || totalDuration < 1) {
    noticeEl.style.display='block';
    noticeEl.innerText = "Impossible de dÃ©terminer les durÃ©es correctement. Les synchronisations peuvent Ãªtre imprÃ©cises.";
  } else {
    noticeEl.style.display='none';
  }

  // debug
  debugArea.innerText = `Pistes: ${tracks.length}\nDurÃ©e totale: ${fmtTime(totalDuration)} (${Math.round(totalDuration)}s)\n\n` + tracks.map((t,i)=>`${i+1}. ${t.title} â€” ${t.artist || '(inconnu)'} â€” ${fmtTime(t.duration)}`).join('\n');
}

/* ---------- Synchronisation: compute current track and offset ---------- */
function computeOrderAndPosition(serverNowSec){
  // deterministic seed from server date (change seed daily so order changes each day but stays same for everyone)
  const daySeed = Math.floor(serverNowSec / 86400); // change every 24h
  seededOrder = shuffleArray(Array.from(tracks.keys()), daySeed);

  // if totalDuration is zero, fallback to simple behavior
  if (!totalDuration || totalDuration <= 0){
    return {index: 0, offset: 0};
  }

  // time into cycle (seconds)
  const timeIntoCycle = serverNowSec % Math.floor(totalDuration || 1);
  // find which track
  let acc = 0;
  for (let i=0;i<seededOrder.length;i++){
    const idx = seededOrder[i];
    const d = tracks[idx].duration || 0;
    if (timeIntoCycle < acc + d){
      return {index: idx, offset: timeIntoCycle - acc, orderPos: i};
    }
    acc += d;
  }
  // fallback: first
  return {index: seededOrder[0], offset: 0, orderPos: 0};
}

/* ---------- Playback management ---------- */
async function initAudioContext(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  gainNode = audioCtx.createGain();
  gainNode.gain.value = parseFloat(volRange.value);
  gainNode.connect(audioCtx.destination);
  // connect each <audio> element to the audioContext when needed
}

function connectElementToContext(audioElem){
  if (!audioCtx) return;
  try{
    const src = audioCtx.createMediaElementSource(audioElem);
    src.connect(gainNode);
  }catch(e){
    // createMediaElementSource may throw if already connected
  }
}

/* play a single track from offset (seconds) â€” stops other tracks */
async function playTrackAt(idx, offset){
  // stop all
  audioEls.forEach(a=>{ try{ a.pause(); }catch(e){} });
  const a = audioEls[idx];
  if (!a) return;
  connectElementToContext(a);
  // set time once canplay
  await new Promise((resolve)=>{
    if (a.readyState >= 2){ resolve(); return; }
    const oncan = ()=>{ resolve(); };
    a.addEventListener('canplay', oncan, {once:true});
    setTimeout(()=>resolve(), 5000);
  });
  try{
    a.currentTime = Math.min(Math.max(0, offset), (a.duration || 0)-0.01);
  }catch(e){}
  try{ await a.play(); }catch(e){}
  started = true;
}

/* ---------- UI update loop ---------- */
let currentPlayingIndex = null;
let currentOrderPos = null;
function startClockLoop(){
  setInterval(async ()=>{
    const clientNow = Date.now();
    const serverNow = new Date(clientNow + serverTimeOffset);
    const serverNowSec = Math.floor(serverNow.getTime()/1000);
    const pos = computeOrderAndPosition(serverNowSec);
    if (pos.index != null){
      const idx = pos.index;
      const offset = pos.offset || 0;
      // if not currently playing or playing a different track -> switch
      if (currentPlayingIndex !== idx || Math.abs((audioEls[idx]?.currentTime||0) - offset) > 1.2){
        // switch
        currentPlayingIndex = idx;
        currentOrderPos = pos.orderPos ?? null;
        await playTrackAt(idx, offset);
      }
      // update UI
      const t = tracks[idx];
      const remaining = (t.duration || 0) - (audioEls[idx]?.currentTime||offset||0);
      artEl.innerHTML = t.artwork ? `<img src="${t.artwork}" style="width:100%;height:100%;object-fit:cover;border-radius:6px">` : (t.artist ? `<div style="padding:6px;text-align:center">${t.artist.replace(/</g,'&lt;')}</div>` : 'â€”');
      trackInfoEl.innerHTML = `<strong>${(t.title||t.filename)}</strong> ${t.artist?` â€” ${t.artist}`:''}`;
      timeInfoEl.innerText = `Temps restant : ${fmtTime(Math.ceil(remaining))} â€¢ Position : ${fmtTime(Math.floor(audioEls[idx]?.currentTime||offset||0))}/${fmtTime(t.duration||0)}`;
      syncStateEl.innerText = `SynchronisÃ© (seed jour ${Math.floor(serverNowSec/86400)})`;
    } else {
      syncStateEl.innerText = 'Pas de piste sÃ©lectionnÃ©e';
    }
  }, 800);
}

/* ---------- Wire controls ---------- */
listenBtn.addEventListener('click', async ()=>{
  listenBtn.disabled = true;
  listenBtn.innerText = 'Initialisationâ€¦';
  try{
    await initAudioContext();
    // resume context on user gesture
    if (audioCtx.state === 'suspended') await audioCtx.resume();

    // compute server time offset
    const serverDate = await fetchServerTime();
    serverTimeOffset = serverDate.getTime() - Date.now();

    // prepare tracks (if not already)
    if (!tracks.length) await prepareTracks();

    // start loop
    startClockLoop();

    listenBtn.style.display='none';
    noticeEl.style.display='none';
  }catch(e){
    console.error(e);
    noticeEl.style.display='block';
    noticeEl.innerText = "Erreur d'initialisation : " + (e && e.message? e.message : String(e));
    listenBtn.disabled = false;
    listenBtn.innerText = 'Ã‰couter';
  }
});

// local volume control
volRange.addEventListener('input', ()=>{
  if (gainNode) gainNode.gain.value = parseFloat(volRange.value);
});

/* ---------- Start preparing metadata in background (non-play) so UI is responsive ---------- */
prepareTracks().then(()=>{
  trackInfoEl.innerText = `${tracks.length} piste(s) prÃªtes â€” appuie sur "Ã‰couter" pour dÃ©marrer la radio.`;
});

/* ---------- Notes & limitations (affichÃ©es discrÃ¨tement) ---------- */
(function showNotes(){
  const n = [];
  n.push("Notes techniques :");
  n.push("- Les MP3 doivent Ãªtre servis depuis la mÃªme origine que cette page (mÃªme domaine).");
  n.push("- Le listing automatique tente /musique/list.json, puis parse un index de rÃ©pertoire HTML. Si Ã©choue, Ã©dite /musique/list.json.");
  n.push("- Synchronisation : rÃ©cupÃ¨re l'en-tÃªte Date du serveur. Si impossible, utilise l'heure locale.");
  n.push("- Recherche de mÃ©tadonnÃ©es : l'API iTunes est utilisÃ©e pour chercher artiste et artwork (pas YouTube directement).");
  debugArea.innerText = (debugArea.innerText?debugArea.innerText + "\n\n":"") + n.join("\n");
})();
</script>
</body>
</html>
